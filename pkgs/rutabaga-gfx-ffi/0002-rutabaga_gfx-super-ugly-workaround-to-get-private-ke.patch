From 76c69111118b9a63cde378f754897f8bdaf123dd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?J=C3=B6rg=20Thalheim?= <joerg@thalheim.io>
Date: Thu, 7 Dec 2023 18:45:37 +0100
Subject: [PATCH 2/3] rutabaga_gfx: super ugly workaround to get private
 keyboard resources forwarded
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: JÃ¶rg Thalheim <joerg@thalheim.io>
---
 .../rutabaga_os/sys/linux/memory_mapping.rs   | 35 +++++++++++++++++--
 1 file changed, 33 insertions(+), 2 deletions(-)

diff --git a/rutabaga_gfx/src/rutabaga_os/sys/linux/memory_mapping.rs b/rutabaga_gfx/src/rutabaga_os/sys/linux/memory_mapping.rs
index f18e3b80a..fe5eb684e 100644
--- a/rutabaga_gfx/src/rutabaga_os/sys/linux/memory_mapping.rs
+++ b/rutabaga_gfx/src/rutabaga_os/sys/linux/memory_mapping.rs
@@ -9,6 +9,7 @@
 use nix::sys::mman::munmap;
 use nix::sys::mman::MapFlags;
 use nix::sys::mman::ProtFlags;
+use nix::errno::Errno;
 
 use crate::rutabaga_os::descriptor::SafeDescriptor;
 use crate::rutabaga_utils::RutabagaError;
@@ -51,15 +52,45 @@ pub fn from_safe_descriptor(
         };
 
         if let Some(non_zero_size) = non_zero_opt {
+
             let addr = unsafe {
-                mmap(
+                let mut res = mmap(
                     None,
                     non_zero_size,
                     prot,
                     MapFlags::MAP_SHARED,
                     Some(descriptor),
                     0,
-                )?
+                );
+                if let Err(Errno::EPERM) = res {
+                    if prot == ProtFlags::PROT_READ {
+                        let tmp = mmap(
+                            None,
+                            non_zero_size,
+                            ProtFlags::PROT_READ,
+                            MapFlags::MAP_PRIVATE,
+                            Some(descriptor),
+                            0)?;
+
+                        let addr = libc::mmap(
+                            std::ptr::null_mut(),
+                            non_zero_size.into(),
+                            libc::PROT_READ|libc::PROT_WRITE,
+                            libc::MAP_SHARED | libc::MAP_ANONYMOUS,
+                            -1,
+                            0);
+
+                        if addr == libc::MAP_FAILED {
+                            munmap(tmp, non_zero_size.into()).unwrap();
+                            return Err(RutabagaError::SpecViolation("failed to mmap"));
+                        } else {
+                            std::ptr::copy_nonoverlapping(tmp, addr, non_zero_size.into());
+                            munmap(tmp, non_zero_size.into()).unwrap();
+                            res = Ok(addr);
+                        }
+                    }
+                }
+                res?
             };
             Ok(MemoryMapping { addr, size })
         } else {
-- 
2.42.0

